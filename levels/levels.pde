/**
  * This sketch demonstrates how to use an FFT to analyze
  * the audio being generated by an AudioPlayer.
  * <p>
  * FFT stands for Fast Fourier Transform, which is a 
  * method of analyzing audio that allows you to visualize 
  * the frequency content of a signal. You've seen 
  * visualizations like this before in music players 
  * and car stereos.
  * <p>
  * For more information about Minim and additional features, 
  * visit http://code.compartmental.net/minim/
  */

import ddf.minim.analysis.*;
import ddf.minim.*;

Minim       minim;
AudioPlayer jingle;
FFT         fft;
PImage space;
int roll = 0;
int BAND_WIDTH = 10;
int runningTotal = 0;  
int lastHeight = 0;
PShader blur;
int beatWeight = 0;
int beatThreshold = 40;
int refreshCount = 0;
int currentPeak = 0;

PGraphics mountainBuffer;


public PImage getReversePImage( PImage image ) {
 PImage reverse = new PImage( image.width, image.height );
 for( int i=0; i < image.width; i++ ){
  for(int j=0; j < image.height; j++){
   reverse.set( image.width - 1 - i, j, image.get(i, j) );
  }
 }
 return reverse;
}

void setup()
{
  size(displayWidth, displayHeight, P3D);
  mountainBuffer = createGraphics(displayWidth, 253);
  space = loadImage("space.jpg");
  blur = loadShader("blur.glsl"); 
  minim = new Minim(this);
  blendMode(ADD);
  
  // specify that we want the audio buffers of the AudioPlayer
  // to be 1024 samples long because our FFT needs to have 
  // a power-of-two buffer size and this is a good size.
  jingle = minim.loadFile("metro.mp3", 1024);
  
  // loop the file indefinitely
  jingle.loop();
  
  // create an FFT object that has a time-domain buffer 
  // the same size as jingle's sample buffer
  // note that this needs to be a power of two 
  // and that it means the size of the spectrum will be half as large.
  fft = new FFT( jingle.bufferSize(), jingle.sampleRate() );
  
}

void draw()
{
  refreshCount++;
  roll++;
  background(0);
  mountainBuffer.beginDraw();
  mountainBuffer.stroke(255, 30, 60);
  noFill();
  // perform a forward FFT on the samples in jingle's mix buffer,
  // which contains the mix of both the left and right channels of the file
  
  if(refreshCount % 4 == 0){
    mountainBuffer.clear();
    fft.forward( jingle.mix );
    for(int i = 0; i < fft.specSize() / 2; i++)
    {
      // draw the line for frequency band i, scaling it up a bit so we can see it
      if(i % BAND_WIDTH != 0){
        //println("Adding: " + i + " : " + runningTotal);
        runningTotal += fft.getBand(i);
      }
      else {
        //println("Averaging");
        //rect( i, displayHeight - (runningTotal / BAND_WIDTH) * 8, i + BAND_WIDTH,  displayHeight);  
        if(i == 10){
          beatWeight = (runningTotal / BAND_WIDTH) * 10;
          if(beatWeight > 255){
            beatWeight = 255; 
            //mountainBuffer.background(beatWeight, beatWeight, beatWeight, 50);
          }
          if(beatWeight > beatThreshold){
            strokeWeight(2);  
          }
          else {
            strokeWeight(1);
          }
          //mountainBuffer.line(0, mountainBuffer.height, mountainBuffer.width / 2, mountainBuffer.height - beatWeight );
          //mountainBuffer.line(mountainBuffer.width / 2, mountainBuffer.height - beatWeight, mountainBuffer.width, mountainBuffer.height  );
        }
        if (lastHeight > 0 || runningTotal / BAND_WIDTH > 0){
          currentPeak = mountainBuffer.height - (runningTotal / BAND_WIDTH) * 20;
          if(currentPeak < 0){
            currentPeak = 0;  
          }
          mountainBuffer.line(i * 6, lastHeight, (i + BAND_WIDTH) * 6, currentPeak );
          lastHeight = currentPeak;  
      }
        runningTotal = 0;
      }
    }  
   
  }
  
  mountainBuffer.endDraw();
  //blendMode(ADD);
  image(mountainBuffer, 0, 0);
  //image(getReversePImage(mountainBuffer), 0 ,0);
  
  
  for( float j=5; j < displayHeight ; j *= 1.2) {
  stroke( 255*noise(j/1.0),255-255*noise(j/1.0), 255, 155);
  //beginShape();
  int h = 250 + int(j);
  line(0,  h , displayWidth, h);
   //line((displayWidth / 2), 0, 50, displayHeight);
  //line(0, 130, displayWidth, 130);
  //line(0, 170, displayWidth, 170);
  //endShape();
  }  
  /*translate(0, 250);  
  rotate(random(0, 360));
  for (int x = 0 - displayWidth * 2; x <= displayWidth * 3; x += 90){
    line(x, displayHeight, displayWidth / 2, 100);
  }
  */
  //if(beatWeight >= beatThreshold){
  //  filter(blur);
  //}
}
